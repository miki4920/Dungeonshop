#pragma kernel ApplyTexture
#pragma kernel ApplyWhiteTexture
#pragma kernel ApplyTextureBasedOnMask
#pragma kernel ApplyColorBasedOnMask
#pragma kernel ApplyEraserBasedOnMask
#pragma kernel UpdateMask

RWTexture2D<float4> canvas;
RWTexture2D<float4> mask;
Texture2D<float4> overlayTexture;
float4 overlayColor;
float4 previousMousePosition;
float4 mousePosition;
float size;
float opacity;



float4 BrushMask(float2 pixelPos, float4 currentColor, float brushSize, float opacity, float2 previousMousePosition,
                 float2 mousePosition)
{
	for (float i = 0; i < 1.0; i += 0.01)
	{
		const float2 mousePos = lerp(previousMousePosition, mousePosition, i);
        if (length(pixelPos - mousePos) < size)
		{
            return float4(1, 1, 1, opacity);
        }
	}
    return currentColor;
}

[numthreads(8, 8, 1)]
void ApplyTexture(uint3 id : SV_DispatchThreadID)
{
	canvas[id.xy].rgba = lerp(canvas[id.xy], overlayTexture[id.xy], overlayTexture[id.xy].a);
}

[numthreads(8, 8, 1)]
void ApplyWhiteTexture(uint3 id : SV_DispatchThreadID)
{
	canvas[id.xy].rgba = float4(1, 1, 1, opacity);
}

[numthreads(8, 8, 1)]
void ApplyTextureBasedOnMask(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy].rgba = lerp(canvas[id.xy], overlayTexture[id.xy], mask[id.xy]);
}

[numthreads(8, 8, 1)]
void ApplyColorBasedOnMask(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy].rgba = lerp(canvas[id.xy], overlayColor, mask[id.xy]);
}

[numthreads(8, 8, 1)]
void ApplyEraserBasedOnMask(uint3 id : SV_DispatchThreadID)
{
    if (mask[id.xy].a > 0)
    {
        canvas[id.xy].rgba = float4(canvas[id.xy].rgb, canvas[id.xy].a * (1 - mask[id.xy].a));
    }
}

[numthreads(8, 8, 1)]
void UpdateMask(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy] = BrushMask(id.xy, canvas[id.xy], size, opacity, previousMousePosition, mousePosition);
}
