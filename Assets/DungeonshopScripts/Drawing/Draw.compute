#pragma kernel ApplyTexture
#pragma kernel ApplyWhiteTexture
#pragma kernel ApplyTextureWithNoLerp
#pragma kernel Update


RWTexture2D<float4> canvas;
RWTexture2D<float4> originalLayer;
float4 previousMousePosition;
float4 mousePosition;
float brushSize;
float brushOpacity;
float opacity;
Texture2D<float4> overlayTexture;

float4 HardBrush(float2 pixelPos, float4 currentColor, Texture2D overlayTexture, float brushSize, float brushOpacity, float2 previousMousePosition,
                 float2 mousePosition)
{  
    for (float i = 0; i < 1.0; i += 0.01)
    {
        const float2 mousePos = lerp(previousMousePosition, mousePosition, i);
        if (length(pixelPos - mousePos) < brushSize)
            return lerp(originalLayer[pixelPos], overlayTexture[pixelPos], brushOpacity);
    }

    return currentColor;
}

[numthreads(8,8,1)]
void ApplyTexture(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy].rgba = lerp(canvas[id.xy], overlayTexture[id.xy], overlayTexture[id.xy].a);
}

[numthreads(8,8,1)]
void ApplyTextureWithNoLerp(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy].rgba = overlayTexture[id.xy];
}

[numthreads(8,8,1)]
void ApplyWhiteTexture(uint3 id : SV_DispatchThreadID)
{
    canvas[id.xy].rgba = float4(255, 255, 255, opacity);
}

[numthreads(8,8,1)]
void Update(uint3 id : SV_DispatchThreadID)
{   
    float4 brushPixel = HardBrush(id.xy, canvas[id.xy], overlayTexture, brushSize, brushOpacity, 
                               previousMousePosition, mousePosition);
    canvas[id.xy].rgba = brushPixel;
}
